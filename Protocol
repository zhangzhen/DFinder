samtools view -bS toy2.sam > toy2.bam
samtools view HuRef_chr21_l75_f6.mka.bam | head
condition for left soft clips: #clips == 1 and Position == genomePosition
condition for right soft clips: #clips == 1 and Length == readPosition + clipSize

统计了不同长度的left clips和right clips的个数，发现有reads被剪掉的部分比保留的部分长。
有一个right clip的长度在56-60之间，具体原因需要调查。

我们用ART模拟生成了HuRef的chr21的长度为75、倍数为6的reads。

Clip: 0, 36605775, 18, 57, ATGACAGGTGTGAGCCACCACCACCAGCNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN - [R]

实现中碰到的问题：
1. 模拟的reads其中有一部分是N，例如：ATGACAGGTGTGAGCCACCACCACCAGCNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
解决：把这些reads滤掉

$ python filter_out_reads.py reads/HuRef_chr21_l75_f6.fq reads/HuRef_chr21_l75_f6_clean.fq
total #reads: 2678676
remaining #reads: 2652723

2. 由于reference基因组存在gaps，有clip的reads不一定说明存在结构变异。这是一个大家容易忽略的问题。
解决办法暂时没有想好

3. 被减掉的长度太短，左右clips长度大于10的各有一个
可能是aligner的参数要设置一下才行

4. 真实数据的reads是否含有N，是连续的，还是不连续的？
一般来说，illumina的reads 测错的比例为1%左右，无缺失。

5. bam里面包含了unique, multiple and unaligned。unique and multiple mapping是很好区分的，但是如何把他们与unaligned区别开来呢？


$ ./clip-sv HuRef_chr21_l75_f6.mka.bam

You got 2652723 alignments.
You got 287182 alignments with soft clipping.

#left breakpoints: 140614
#right breakpoints: 135778

results.txt - #clips in length 1 to 5
121676	9149	7351	1197	872

results2.txt - #clips with the witdh of bins = 5
140245	368	1	0	0	0	0	0	0	0	0	0	0	0	0	
135394	383	1	0	0	0	0	0	0	0	0	0	0	0	0	


Hi there,

We have been using the split read methodology quite a bit with MOSAIK.

We have a new version out that makes this available to the masses. In addition to MOSAIK, we used some external code for our split-read alignments.

Briefly, our process is as follows:

1. Align the reads against a reference sequence, but remember to store the unaligned reads (-rur parameter).

e.g. "-rur ChrX_unaligned.fq" will store the unaligned reads in the specified fastq file.

2. Build a new read archive using the unaligned reads from step 1.

3. We align the reads as normal, but instead of requiring the entire read to align, we specify that we want to align at least X bp of a read (-min X).

Normally, MOSAIK will count the unaligned portions of the read as mismatches. In this case, this is not what we want - so we deactivate that using the -mmal parameter.

e.g. If I wanted to align at least 32 bp of a read, I would add "-min 32 -mmal" to my MosaikAligner command line.

These reads didn't align to the reference for a reason. One of those reasons will be because they align to a non-contiguous span. A good example of this is aligning to the end of one exon to the beginning of another exon.

3. Using some in-house programs, we take those alignments, trim off the parts that aligned, create a new read archive, and align the reads yet again. 

You can easily do something similar with the MosaikTools C++ or Perl API. Or you could export the reads into some other format and work from there.

The reads that aligned to two significant regions are prime candidates for split-read structural variations.

Cheers,

